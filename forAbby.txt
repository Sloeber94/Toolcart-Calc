import os
import pandas as pd
import streamlit as st
from typing import Dict, Any
from config import DEFAULTS, SLIDERS, NUMBER_RANGES
from cutlist_calculator import calculate_drawer,generate_cutlist, generate_drawer_cutlist, calculate_toolbox_frame

def load_css():
    css_path = "styles.css"
    if os.path.exists(css_path):
        with open(css_path, "r", encoding="utf-8") as f:
            st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)

load_css()

st.set_page_config(page_title="Drawer Calculator", layout="wide")


st.title("ðŸ”¨ Verschraubt.ch: Tool Trolley Project Calculator")
st.markdown(
    "Fully customizable by you, just enter your requirements and let it calculate your materials."
)
with st.sidebar:
    st.header("ðŸ“ Configuration")
    gf_mode = st.sidebar.checkbox("Gridfinity Mode")

    #gridfinity units
    ss = 0.5 if gf_mode else 1.0 #0.5u GF or 1 mm
    ms = 1 if gf_mode else 5 #1.0u GF or 5 mm
    gf = 42

    #drawer dimensions
    drwStep = ms if gf_mode else 50 #drawer slide stroke length in 50 mm or gf units with small under/overlap
    drwMin = 0
    drwMax = 40 if gf_mode else 2000 #max width
    drwWmax = 40 if gf_mode else 1000 #max depth
    drwDef = drwMax//2 #default slider value
    lblQt = "u" if gf_mode else "mm" #units in u (GF units) or mm
    gfStep = gf if gf_mode else 1 #conversion to mm step if GF chosen
    nMin = 0 #amount of drawers minimum value
    nMax = 20 #amount of drawers maximum value

    hMin = float(0) #min drawer height
    hMax = float(12 if gf_mode else 500) #max drawer height
    hDef = float(1 if gf_mode else 50) #default drawer height

    #design defaults
    tBox=15 #thickness drawer box material
    tBase=5 #thickness drawer base material
    tBkt=2 #thickness drawer bracket
    sRear = 40 #distance rear drawer slide to outer frame
    sRear40 = 20
    sRear80 = 35
    sDrw = 2 #drawer spacing
    sDadoMax =tBox//2 #dado depth in sides and fronts
    sFront = 5 #distance front drawer slide to outer frame
    w4040=40 #alu profile side 
    w4080=80 #alu profile side



    tabs = st.tabs(["Input", "Constants", "Fine-tuning"])  # Type hint for clarity
    # TAB 0: INPUTS - Fixed formats
    with tabs[0]:
        # Width
        col1, col2 = st.columns([4, 1])
        with col1:
            drwLu = st.slider("Drawer Width", drwMin, drwMax, drwDef, ms, format=f"%g {lblQt}")
            drwL = drwLu * gfStep
        with col2:
            if gf_mode: 
                st.caption(f"{int(drwL)} mm", text_alignment="right")

        # Depth
        col1, col2 = st.columns([4, 1])
        with col1:
            drwWu = st.slider("Drawer Depth", drwMin, drwWmax, drwDef, drwStep, format=f"%g {lblQt}")
            drwW = drwWu * gfStep
        with col2:
            if gf_mode:
                st.caption(f"{int(drwW)} mm", text_alignment="right")

        st.subheader("Drawer Heights")
        # Top
        col1, col2 = st.columns([4, 1])
        with col1:
            drwHtu = st.slider("Top", hMin, hMax, hDef, ss, format=f"%.1f {lblQt}")
            drwHt = drwHtu * gfStep
        with col2:
            if gf_mode:
                st.caption(f"{int(drwHt)} mm", text_alignment="center")

        # Middle  
        col1, col2 = st.columns([4, 1])
        with col1:
            drwHmu = st.slider("Middle", hMin, hMax, hDef, ss, format=f"%.1f {lblQt}")
            drwHm = drwHmu * gfStep
        with col2:
            if gf_mode:
                st.caption(f"{int(drwHm)} mm", text_alignment="center")

        # Bottom
        col1, col2 = st.columns([4, 1])
        with col1:
            drwHbu = st.slider("Bottom", hMin, hMax, hDef, ss, format=f"%.1f {lblQt}")
            drwHb = drwHbu * gfStep
        with col2:
            if gf_mode:
                st.caption(f"{int(drwHb)} mm", text_alignment="center")

        st.subheader("Drawer Quantities")
        col1, col2 = st.columns([4, 1])
        with col1:
            nDrwT = st.slider("Top", nMin, nMax, 7, 1, format="%d pcs")
        with col2:
            pass
        col1, col2 = st.columns([4, 1])
        with col1:
            nDrwM = st.slider("Middle", nMin, nMax, 4, 1, format="%d pcs")
        with col2:
            pass
        col1, col2 = st.columns([4, 1])
        with col1:
            nDrwB = st.slider("Bottom", nMin, nMax, 2, 1, format="%d pcs")
        with col2:
            pass


        st.subheader("Accessoires")
        hCastors=st.slider("Castors Height", 0, 200, 125, 1, format="%.1d mm")
        tTbl=st.slider("Tabletop thickness", 0, 50, 20, 1, format="%.1d mm")

    # TAB 1: CONSTANTS - Fixed formats
    with tabs[1]:
        st.subheader("Prices")
        col1, col2 = st.columns(2)
        with col1:
            cBox = st.number_input("Plywood CHF/mÂ²", value=25.0, min_value=0.0, max_value=200.0, step=1.0, format="%.0f")
        with col2:
            cBase = st.number_input("Base CHF/mÂ² ", value=15.0, min_value=0.0, max_value=200.0, step=1.0, format="%.0f")
        st.subheader("Drawer Slides")

        # Slide matrix - background data only
        slide_data = [
            ["Basic", "Light", 5, 12.0],
            ["Basic", "Medium", 8, 15.0],
            ["Basic", "Heavy", 10, 19.0],
            ["Bumper", "Light", 8, 15.0],
            ["Bumper", "Medium", 11, 19.0],
            ["Bumper", "Heavy", 14, 22.0],
            ["Soft-Close", "Light", 12, 19.0],
            ["Soft-Close", "Medium", 16, 22.0],
            ["Soft-Close", "Heavy", 20, 25.0],
            ["Push-to-Open", "Light", 15, 22.0],
            ["Push-to-Open", "Medium", 19, 25.0],
            ["Push-to-Open", "Heavy", 24, 28.0],
        ]

        # Lookup function
        def get_slide_data(feature, load_class):
            for row in slide_data:
                if row[0] == feature and row[1] == load_class:
                    return row[2], row[3]
            return 10, 19.0  # default

        # SINGLE dropdown set - 2-column row
        col1, col2 = st.columns(2)
        with col1:
            selected_feature = st.selectbox("Features", ["Basic", "Bumper", "Soft-Close", "Push-to-Open"], index=0)
        with col2:
            selected_load = st.selectbox("Load Class", ["Light", "Medium", "Heavy"], index=1)

            # Extract and display values
        cSlides, tSlides = get_slide_data(selected_feature, selected_load)
        st.caption(f"Price per pair: {cSlides} CHF", text_alignment="center")
        st.caption(f"Slide Thickness: {tSlides:.1f} mm", text_alignment="center")

        st.subheader("Dimensions")
        col1, col2 = st.columns([2,3])
        with col1:
            uprights = st.radio("Uprights profile", ["4040", "4080"], index=0)
        if uprights == "4040":  # Fixed ==
            frame_clear = 10
            tUprights=w4040
        else:
            frame_clear = 50
            tUprights=w4080
        with col2:
                front_clear_man = st.number_input("Front Clearance", value=sFront, min_value=0, max_value=100, step=1, help="Optional: change distance from drawer slides to front of frame or leave as is")
                frame_clear_man = st.number_input("Rear Clearance", value=frame_clear, min_value=0, max_value=100, step=1, help="Changes on profile selection, change only when required.")
        sRear = frame_clear_man
        sFront = front_clear_man

        st.subheader("Wood Dimensions")
        col1, col2, col3 = st.columns([2,2,2])
        with col1:
            t_box = st.slider("Plywood thickness", 0, 30, tBox, 1, format="%.0f mm")
        with col2:
            t_base = st.slider("Base thickness", 0, 30, tBase, 1, format="%.0f mm")
        tBox: float = t_box
        tBase: float = t_base
        sDadoMax = tBox//2
        sDado_auto = tBox//2
        with col3:
            # Harden slider bounds so Streamlit never receives min_value >= max_value
            min_val = 2
            safe_sDadoMax = max(int(sDadoMax), min_val + 1)
            max_val = max(safe_sDadoMax, min_val + 1)
            sDado_default = min(max(int(sDado_auto), min_val), max_val - 1)
            sDado = st.slider(
                "Dado depth",
                min_value=min_val,
                max_value=max_val,
                value=sDado_default,
                step=1,
                format="%.0f mm",
                help="Default to <50% of Plywood thickness",
            )

    # TAB 2: FINE-TUNING
    with tabs[2]:
        st.subheader("Fine-tuning Adjustments")
        st.write("If you want rounded frame dimensions, e.g., 1200mm instead of 1184mm, use these adjustments to fine-tune the final frame sizes.")

        adjust_outer_width = st.number_input("Adjust Frame Outer Width (mm)", value=0, min_value=-100, max_value=100, step=1)
        adjust_outer_depth = st.number_input("Adjust Frame Outer Depth (mm)", value=0, min_value=-100, max_value=100, step=1)
        adjust_outer_height = st.number_input("Adjust Frame Outer Height (mm)", value=0, min_value=-100, max_value=100, step=1)
        adjust_inner_width = st.number_input("Adjust Frame Inner Width (mm)", value=0, min_value=-100, max_value=100, step=1)
        adjust_inner_depth = st.number_input("Adjust Frame Inner Depth (mm)", value=0, min_value=-100, max_value=100, step=1)
        adjust_inner_height = st.number_input("Adjust Frame Inner Height (mm)", value=0, min_value=-100, max_value=100, step=1)
        adjust_drawer_spacing = st.number_input("Adjust Drawer Spacing (mm)", value=0, min_value=-50, max_value=50, step=1)

        st.write("**How adjustments affect dimensions:**")
        st.write("- **Adjust Frame Outer Width:** Modifies drawer width.")
        st.write("- **Adjust Frame Inner Width:** Modifies drawer width.")
        st.write("- **Adjust Frame Outer Depth:** Plays with front clearance, rear clearance, or drawer depth.")
        st.write("- **Adjust Frame Inner Depth:** Plays with front clearance, rear clearance, or drawer depth.")
        st.write("- **Adjust Frame Outer Height:** Modifies castors height, tabletop thickness, top/middle/bottom drawer height, or drawer spacing.")
        st.write("- **Adjust Frame Inner Height:** Modifies top/middle/bottom drawer height or drawer spacing.")



# CALCULATIONS
# -----------------------------
result = calculate_drawer(drwL,drwW,drwHt,drwHm,drwHb,tBox,sDado,cBox,cBase)

nDrw = nDrwT+nDrwM+nDrwB #total drawers
slides_cost = nDrw * cSlides

frame = calculate_toolbox_frame(
    result,           # calculate_drawer output
    tSlides,          # slide_thickness  
    sRear,            # Back Spacing (dist drawer slide to outer frame)
    sFront,           # Front spacing (dist drawer to outer frame)
    nDrwT,            # Top drawer count              
    nDrwM,            # Middle drawer count
    nDrwB,            # Bottom drawer count
    nDrw,             # total drawers
    sDrw,             # spacing per drawer
    tBkt              # Thickness Drawer Bracket    
)



frmHi, frmWi, frmDo, sDrwTot = frame.values()
##intermediate calcs
frmHo = frmHi+2*w4040
frmWo = frmWi+2*w4040
frmDi = frmDo-2*tUprights
trlH = frmHo+hCastors+tTbl
trlW=frmWo
trlD=frmDo

# Apply fine-tuning adjustments
frmWo += adjust_outer_width
frmDo += adjust_outer_depth
frmHo += adjust_outer_height
frmWi += adjust_inner_width
frmDi += adjust_inner_depth
frmHi += adjust_inner_height
sDrwTot += adjust_drawer_spacing
# -----------------------------
# FRAME DISPLAY
# -----------------------------
st.subheader("ðŸ› ï¸ Tool Trolley frame dimensions")
col1, col2, col3 = st.columns(3)
with col1:
    st.metric("Frame outer Width", f"{frmWo:.0f} mm")
    st.metric("Frame inner Width",f"{frmWi:.0f} mm")
with col2:
    st.metric("Frame outer Depth", f"{frmDo:.0f} mm")
    st.metric("Frame inner Depth",f"{frmDi:.0f} mm")
with col3:
    st.metric("Frame outer Height",f"{frmHo:.0f} mm")
    st.metric("Frame inner Height",f"{frmHi:.0f} mm")

with st.expander("Frame Details"):
    st.info(f"Total spacing: {sDrwTot:.0f} mm")
    st.info(f"Tabletop working height: {trlH:.0f} mm")
   

# -----------------------------
# CABINET DIMENSIONS
# -----------------------------
# st.subheader("Cabinet Dimensions")
# col1, col2, col3, col4 = st.columns(4)
# with col1:
#     st.metric("Inner Width", f"{result['dimensions']['Wi']} mm")
# with col2:
#     st.metric("Inner Depth", f"{result['dimensions']['Di']} mm")
# with col3:
#     st.metric("Outer Width", f"{result['dimensions']['Wo']} mm")
# with col4:
#     st.metric("Outer Depth", f"{result['dimensions']['Do']} mm")

# -----------------------------

# -----------------------------
# CUTLIST (MERGED)
# -----------------------------
st.subheader("ðŸ“‹ Cutlist of Wood and Profiles")

# After result = calculate_drawer(...)
drawer_parts = generate_drawer_cutlist(result, nDrwT, nDrwM, nDrwB)

# Add frame/tabletop (keep in app.py - simple)
# profile thickness for profiles (use upright profile thickness)
profile_thick = tUprights

all_parts = drawer_parts + [
    {"Part": "Profile Verticals", "L (mm)": frmHo, "W (mm)": profile_thick, "Qty": 4},
    {"Part": "Profile Horizontals", "L (mm)": frmWo, "W (mm)": profile_thick, "Qty": 4},  # Assuming top and bottom
    {"Part": "Plywood Tabletop", "L (mm)": frmWo+50, "W (mm)": frmDi+50, "Qty": 1}
]

df_raw = pd.DataFrame(all_parts)
df_merged = df_raw.groupby(["Part", "L (mm)", "W (mm)"]).agg({"Qty": "sum"}).reset_index()
st.dataframe(df_merged)


# PRICE SUMMARY  # Extract to function for separation of concerns
# -----------------------------
st.subheader("ðŸ’° Cost Summary")

# Drawer costs (total wood area Ã— price/mÂ²)
drawers_area_panels = (result["low"]["A_panels_m2"] * nDrwT + 
                      result["mid"]["A_panels_m2"] * nDrwM + 
                      result["high"]["A_panels_m2"] * nDrwB)
drawers_area_bases = (result["low"]["A_base_m2"] * nDrwT + 
                     result["mid"]["A_base_m2"] * nDrwM + 
                     result["high"]["A_base_m2"] * nDrwB)

cost_drawers_panels = drawers_area_panels * cBox
cost_drawers_bases = drawers_area_bases * cBase
cost_drawers_total = cost_drawers_panels + cost_drawers_bases

# Slides + brackets (4 brackets/drawer = 2 brackets/slide Ã— 2 slides/drawer)
cost_slides: float = slides_cost  # nDrw Ã— cSlides (pairs)  # Type hint
cBracket = 2.50  # CHF per bracket (draft)
cost_brackets = nDrw * 4 * cBracket

# Hardware totals
cost_hardware = cost_slides + cost_brackets  # + castors + tabletop + fasteners later

# Frame (TODO)
# profile_length_m = (2*frmHo + 2*frmWo + 2*frmDo) / 1000  # Perimeter Ã— height
# cProfile = 15  # CHF/m 4040 profile
# cost_frame = profile_length_m * cProfile

col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric("ðŸªµ Drawers Panels", f"CHF {cost_drawers_panels:.1f}")
with col2:
    st.metric("ðŸªµ Drawers Bases", f"CHF {cost_drawers_bases:.1f}")
with col3:
    st.metric("ðŸ”© Slides+Brackets", f"CHF {cost_hardware:.1f}")
with col4:
    st.metric("ðŸ—ï¸ Frame", "TBD")  # TODO: profile cutlist

# GRAND TOTAL
total_cost: float = cost_drawers_total + cost_hardware  # + cost_frame later  # Type hint
st.metric("**GRAND TOTAL**", f"**CHF {total_cost:.1f}**", 
          help=f"Drawers: {cost_drawers_total:.1f} + Hardware: {cost_hardware:.1f}")

with st.expander("Cost Breakdown"):
    st.info(f"**Drawers total area:** Panels {drawers_area_panels:.3f}mÂ² Ã— {cBox}CHF = {cost_drawers_panels:.1f}CHF")
    st.info(f"**Bases total area:** {drawers_area_bases:.3f}mÂ² Ã— {cBase}CHF = {cost_drawers_bases:.1f}CHF") 
    st.info(f"**Hardware:** {nDrw} slides ({slides_cost:.1f}CHF) + {nDrw*4} brackets ({cost_brackets:.1f}CHF)")

config.py

"""Drawer Calculator Defaults + Sliders"""
from typing import Dict, Tuple, Any

# Fixed Defaults
DEFAULTS = {
    # Dimensions
    "Wi": 20*42, "Di": 462,
    
    # Heights
    "hl": 80, "hm": 150, "hh": 250,
    
    # Quantities
    "nl": 7, "nm": 4, "nh": 2,
    
    # Prices & Hardware
    "Cp": 30.0, "Cb": 10.0,
    "slide_price": 15.0,
    "slide_thick": 25.0, 
    "frame_clear": 50.0,
    "td": 6.0, "t": 15.0,
}

# Slider Tuples: (min, max, default, step)  # Use TypedDict for better typing
SLIDERS: Dict[str, Tuple[float, float, float, float]] = {
    # Dimensions
    "Wi": (50, 2000, DEFAULTS["Wi"], 10),
    "Di": (50, 2000, DEFAULTS["Di"], 10),
    
    # Heights
    "hl": (40, 300, DEFAULTS["hl"], 10),
    "hm": (40, 300, DEFAULTS["hm"], 10),
    "hh": (40, 300, DEFAULTS["hh"], 10),
    
    # Quantities (int step=1)
    "nl": (0, 10, DEFAULTS["nl"], 1),
    "nm": (0, 10, DEFAULTS["nm"], 1),
    "nh": (0, 10, DEFAULTS["nh"], 1),
    
    # Slides
    "slide_price": (5.0, 25.0, DEFAULTS["slide_price"], 0.5),
    "slide_thick": (10.0, 30.0, DEFAULTS["slide_thick"], 0.1),
}
  # Consider using a dataclass for DEFAULTS to avoid dict access errors
# Number Input Ranges (min, max, step)
NUMBER_RANGES = {
    "Cp": (5.0, 100.0, 1.0),
    "Cb": (2.0, 50.0, 1.0),
    "frame_clear": (30.0, 100.0, 5.0),
    "td": (3.0, 15.0, 0.1),
    "t": (5.0, 30.0, 0.1),
}

# Gridfinity (1U = 42mm width/depth, 7mm height â†’ 0.5U=21mm, 1U=42mm)
GRIDFINITY = {
    "unit": 42,      # Width/depth step
    "half_unit": 21, # Height 0.5U
    "unit_height": 42,  # Height 1U (6x7mm)
    "clearance": 0.5,   # Optional bin clearance
}


cutlist_calculator.py


from typing import Dict, List, Any

def calculate_toolbox_frame(drawers: Dict[str, Any], tSlides: float, sRear: float, sFront: float, nDrwT: int, nDrwM: int, nDrwB: int, nDrw: int, sDrw: float, tBkt: float) -> Dict[str, float]:
    """
    Calculate toolbox frame dimensions around drawer stack.
    
    Args:
        drawers: result dict from calculate_drawer()
        tSlides: Drawer slide thickness (mm)
        sRear: Rear clearance behind drawers (mm) 
        sFront: 
        nDrwT: Number of top drawers
        nDrwM: Number of mid drawers
        nDrwB: Number of bottom drawers
        nDrw: Total drawers
        sDrw: Spacing between drawers (mm)
        tBkt: Thickness drawer bracket
    
    Returns:
        dict with frame dimensions and spacing info
    """

    dims = drawers['dimensions']
    
    # Dynamic total height from quantities
    h_total = (drawers['low']['height'] * nDrwT + 
               drawers['mid']['height'] * nDrwM + 
               drawers['high']['height'] * nDrwB)
    
    sDrwTot = (nDrw + 1) * sDrw

   #Dimensions for: Length * Width * Height 
    #Drawers:       Width  * Depth * Height
    #Frame:         Width  * Depth * Height


    frmHi = h_total + sDrwTot
    frmWi = dims['Wo'] + 2 * (tSlides+tBkt)
    frmDo = dims['Do'] + sRear+sFront
    
    if sDrwTot == 0: raise ValueError("Spacing cannot be zero")  # Validation
    return {
        'frmHi': frmHi,
        'frmWi': frmWi,
        'frmDo': frmDo,
        'sDrwTot': sDrwTot,

    }

def calculate_drawer(drwL: float, drwW: float, drwHt: float, drwHm: float, drwHb: float, tBox: float, sDado: float, cBox: float, cBase: float) -> Dict[str, Any]:
    """
    Calculate cost and cutlist for drawer boxes.
    
    Args:
        drwL: drawer Length (Inner width)
        drwW: drawer Width (Inner depth)
        drwHt, drwHm, drwHb: Top, Mid, Bottom drawer heights
        tBox: Material thickness sides
        sDado: Dado thickness (mm, default 6)
        cBox: CHF per mÂ² sides
        cBase: CHF per mÂ² base
    
    Returns:
        dict with calculations for each height
    """
    Wi = drwL
    Di = drwW
    Wo = Wi + 2 * tBox
    Do = Di + 2 * tBox
    Wb = Wi + 2 * sDado
    Db = Di + 2 * sDado
    
    def cost_for_height(h):
        A_front = 2 * (Wi * h) * 1e-6
        A_sides = 2 * (Do * h) * 1e-6
        A_panels = A_front + A_sides
        A_base = (Wb * Db) * 1e-6 if Wb > 0 and Db > 0 else 0  # Avoid negatives
        
        y_panels = cBox * A_panels
        y_base = cBase * A_base
        y_total = y_panels + y_base
        
        return {
            'height': h,
            'A_front_m2': A_front,
            'A_sides_m2': A_sides,
            'A_panels_m2': A_panels,
            'A_base_m2': A_base,
            'cost_panels': y_panels,
            'cost_base': y_base,
            'cost_total': y_total
        }
    
    return {
        'low': cost_for_height(drwHt),
        'mid': cost_for_height(drwHm),
        'high': cost_for_height(drwHb),
        'dimensions': {
            'drwL': drwL, 'drwW': drwW,
            'Wo': Wo, 'Do': Do,
            'Wb': Wb, 'Db': Db  # Ensure positive values
        }
    }

def generate_drawer_cutlist(result, nDrwT, nDrwM, nDrwB):
    """Generate complete drawer cutlist from result dict."""
    all_parts = []
    dims = result['dimensions']
    
    for drawer_type, height_key, qty in [
        ("Top", "low", nDrwT),
        ("Mid", "mid", nDrwM), 
        ("Bottom", "high", nDrwB)
    ]:
        h = result[height_key]['height']
        
        # Generate parts for this height
        parts = generate_cutlist(
            drwL=dims['drwL'], drwW=dims['drwW'], 
            h=h, Wo=dims['Wo'], Do=dims['Do'], 
            Wb=dims['Wb'], Db=dims['Db'], qty=qty
        )
        
        # Add drawer type
        for part in parts:
            part['Drawer'] = drawer_type
            
        all_parts.extend(parts)
    
    return all_parts

# Your existing single-drawer function (unchanged)
def generate_cutlist(drwL, drwW, h, Wo, Do, Wb, Db, qty=1):
    """Generate cutlist table for one drawer height."""
    return [  # Updated keys to match table
        {'Part': 'Fronts', 'Qty': 2*qty, 'L (mm)': drwL, 'W (mm)': h},
        {'Part': 'Sides', 'Qty': 2*qty, 'L (mm)': Do, 'W (mm)': h},
        {'Part': 'Base', 'Qty': qty, 'L (mm)': Wb, 'W (mm)': Db}
    ]


